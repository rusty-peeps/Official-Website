[
  {
    "id": "00001",
    "title": "Understanding Ownership in Rust",
    "price": "₹30.00",
    "description1": "In Rust, ownership is a foundational concept that ensures memory safety without a garbage collector. This course will cover how ownership works, borrowing rules, and how Rust enforces memory management at compile time, avoiding runtime errors. You'll learn how to work with variables and references, and how Rust handles memory automatically with its ownership system.",
    "description2": "You’ll explore in-depth the mechanics of ownership, borrowing, and lifetimes, which are vital to prevent memory leaks and dangling pointers. This course will equip you with the knowledge to write efficient, memory-safe Rust programs that are reliable and performant.",
    "sub_header": "Core Concepts You Will Explore",
    "listData": [
      "Mastering the Ownership Model in Rust",
      "Borrowing and References: Deep Dive",
      "Understanding Lifetimes and Memory Management",
      "How Rust Prevents Memory Leaks and Errors"
    ]
  },
  {
    "id": "00002",
    "title": "Rust Traits and Generics",
    "price": "₹22.00",
    "description1": "Traits and generics in Rust enable you to write reusable and type-safe code. In this course, we’ll teach you how to define and implement traits to create flexible and scalable solutions. You’ll also learn how to use generics with structs and functions, allowing you to write more concise and maintainable code.",
    "description2": "This course will focus on creating custom types and leveraging Rust's powerful trait system to achieve maximum reusability. You will be able to understand and implement trait bounds, allowing your functions and types to work in a variety of contexts without sacrificing type safety.",
    "sub_header": "What You Will Achieve by the End",
    "listData": [
      "Creating Custom Traits for Flexibility",
      "Implementing Generics in Rust Code",
      "Working with Trait Bounds for Type Safety",
      "How Traits Improve Reusability in Rust"
    ]
  },
  {
    "id": "00003",
    "title": "Effective Error Handling in Rust",
    "price": "₹25.00",
    "description1": "Rust offers powerful tools to handle errors gracefully, and this course focuses on using `Result` and `Option` enums to write robust, error-free applications. We’ll dive into the error handling mechanisms in Rust, such as the `?` operator, and how it makes your code more concise and readable while handling failures effectively.",
    "description2": "You will learn how to propagate errors, create custom error types, and implement custom error handling logic using Rust's error traits. By the end of this course, you'll be confident in using Rust’s advanced error handling techniques to build more reliable and fault-tolerant applications.",
    "sub_header": "Error Handling Mastery",
    "listData": [
      "Using `Result` and `Option` for Error Handling",
      "Graceful Error Propagation with the `?` Operator",
      "Custom Error Types and Traits",
      "Techniques for Writing Robust Rust Code"
    ]
  },
  {
    "id": "00004",
    "title": "Asynchronous Programming with Rust",
    "price": "₹30.00",
    "description1": "Rust provides excellent support for concurrent programming through its async/await features. In this course, you will learn how to write asynchronous code in Rust to handle concurrent tasks effectively. You will also explore how libraries like `tokio` and `async-std` can be used to write scalable applications that can handle thousands of tasks at the same time.",
    "description2": "Asynchronous programming is essential for handling I/O-bound tasks and building highly concurrent applications. This course will introduce you to the tools and concepts you need to write non-blocking code using Rust's async/await model, streams, and tasks.",
    "sub_header": "Concurrency and Asynchronous Programming",
    "listData": [
      "Using `async` and `await` for Concurrency",
      "Introduction to `tokio` and `async-std` Libraries",
      "Writing Efficient Non-blocking Code",
      "Managing Concurrent Tasks with Rust"
    ]
  },
  {
    "id": "00005",
    "title": "Rust Macros and Metaprogramming",
    "price": "₹28.00",
    "description1": "Rust macros are a powerful tool that allows you to write code that writes code. This course will teach you the basics of declarative macros using `macro_rules!` and introduce you to procedural macros, which give you more control over the Rust syntax and allow you to create complex abstractions.",
    "description2": "In addition to declarative macros, we’ll explore metaprogramming techniques and how you can use macros to automate repetitive code, handle various types of input, and create libraries with flexible APIs. This course will help you unlock the full potential of Rust’s metaprogramming capabilities.",
    "sub_header": "Mastering Macros and Code Generation",
    "listData": [
      "Using `macro_rules!` for Declarative Macros",
      "Creating Procedural Macros for Custom Code Generation",
      "Metaprogramming Concepts and Techniques",
      "Creating Libraries with Rust Macros"
    ]
  },
  {
    "id": "00006",
    "title": "Memory Safety in Rust",
    "price": "₹19.00",
    "description1": "Rust is designed with memory safety in mind, and this course will show you how its ownership, borrowing, and lifetimes systems eliminate common memory errors. Unlike other languages that rely on garbage collectors, Rust ensures safe memory management at compile time, preventing runtime errors like dangling pointers and buffer overflows.",
    "description2": "In this course, we’ll go through the core principles of memory safety in Rust. You’ll learn how Rust's ownership rules ensure that data is never accessed after it has been freed, how borrowing works to allow multiple references to data without conflicts, and how safe concurrency is handled in multi-threaded programs.",
    "sub_header": "Ensuring Memory Safety with Rust",
    "listData": [
      "How Rust Guarantees Memory Safety at Compile Time",
      "Understanding Ownership and Borrowing Rules",
      "Preventing Memory Errors with Lifetimes",
      "Safe Concurrency and Multi-threading in Rust"
    ]
  }
]
